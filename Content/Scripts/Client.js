/// <reference path="_vsIntellisense.js" /> 
///

//Encryption Formatter.
var JsonFormatter = {
    stringify: function (cipherParams) {
        // create json object with ciphertext
        var jsonObj = {
            ct: cipherParams.ciphertext.toString(CryptoJS.enc.Base64)
        };

        // optionally add iv and salt
        if (cipherParams.iv) {
            jsonObj.iv = cipherParams.iv.toString();
        }

        // stringify json object
        return JSON.stringify(jsonObj);
    },

    parse: function (jsonStr) {
        // parse json string
        var jsonObj = JSON.parse(jsonStr);

        // extract ciphertext from json object, and create cipher params object
        var cipherParams = CryptoJS.lib.CipherParams.create({
            ciphertext: CryptoJS.enc.Base64.parse(jsonObj.ct)
        });

        // optionally extract iv and salt
        if (jsonObj.iv) {
            cipherParams.iv = CryptoJS.enc.Hex.parse(jsonObj.iv)
        }

        return cipherParams;
    }
};

//Ember configuration.
App = Ember.Application.create();

App.Router.map(function () {
    //Simplistic Router mainly due to the relative simplicity of the client.
    this.resource('chat');
});

//Ember Objects
App.User = Ember.Object.extend({
    //Username
    name: "",
    //Socket Id generated by the server.
    id: "",
    //Current chat status.
    status: true,
});

App.Message = Ember.Object.extend({
    //Name of the sender.
    name: "",
    //Actual message data however not necesarily a string, it could be binary if it is a file message.
    message: null,
    //Computed to determine if from the SERVER or a client.
    fromServer: function () {
        var name = this.get('name');
        return (name === "SERVER");
    }.property('name'),
    //Timestamp of the message.
    postedAt: new Date()
});

App.Room = Ember.Object.extend({
    //Name of the current Room.
    name: "",
    //Plain text password enterd by the user.
    password: "",
    //Random salt of length 1024, either generated by the client when a new room is created or retrieved from the server on connect to a room.
    salt: null,
    //Key generated based on the password and salt, using a PBKDF2 function with 1000 iterations, key length of 256bit.
    key: null,
    //Main User list for the chat room.
    users: null,
    //Man message list for the chat room. Only contains text based messages.
    messages: null
});

App.Client = App.User.extend({
    //Simple background worker to ensure timestamps are relative and other minor things will be added later.
    backgroundWorker: 0,
    //Whether or not the client is connected to the socket server.
    connected: false,
    //The current time of the client.
    currentTime: new Date(),
    //The currently joined chat room.
    //TODO:: remove current user from the list.
    currentRoom: App.Room.create({
        name: "",
        password: "",
        salt: null,
        key: null,
        users: Em.A([]),
        messages: Em.A([])
    })
});

//Local storage object for the current client.
App.CurrentClient;

//Ember Routing and Controllers.

//Setup of main Index
//Set App.CurrentClient to the model and have the controller content set to the model.
App.IndexRoute = Ember.Route.extend({
    model: function () {
        return (App.CurrentClient = App.Client.create());
    },
    setupController: function (controller, model) {
        controller.set('content', model);
    }
});

//Implements startNew which will setup a new connection to a room and either join it or create it if it has not been created yet.
//This is a series of server calls with attached client side callbacks, which domino through to complete the connection.
//This is one area that needs way more work. To not only make it faster but more secure.
App.IndexController = Ember.ObjectController.extend({
    startNew: function () {

        //Get the inputed room name and store it.
        var roomName = App.CurrentClient.get('currentRoom').get('name');

        //Setup first emit data packet.
        var emitData = {
            room: roomName
        };

        //Emit the first step of the connection. See Sever.js for more details on the server side implications.
        Socket.emit('setupUser', emitData, function (data) {
            //Call back to set up credentials for the room.

            //Get a copy of the currentRoom object.
            var room = App.CurrentClient.get('currentRoom');

            //Check data from server to determine creation of a new salt or usage of a supplied one.
            if (data && data.salt && data.roomExists) {
                //If the room exists and the server supplied the salt generate a key with the user inputed password.
                var password = room.get('password');
                //The salt is stored as a hex string in the server.
                var salt = CryptoJS.enc.Hex.parse(data.salt);
                //Uses 1000 iterations for the sake of development and not waiting forever on each test. This will be increased later on and should be for serious use of the application.
                //Also there will be a loading screen for while the generation is in progress.
                var key = CryptoJS.PBKDF2(password, salt, { keySize: 256 / 32, iterations: 1000 });
                //Set the appropriate properties.
                room.set('salt', salt);
                room.set('key', key);
            } else if (data && !data.roomExists && data.salt === null) {
                //If the room does not exist and no salt has been provided which is supposed to happen on the event of no room being available with the supplied name.
                //Generate a salt of length 1024 bytes, and then generate a key based on that salt and the user supplied password.
                var password = room.get('password');
                var salt = CryptoJS.lib.WordArray.random(1024 / 8);
                var key = CryptoJS.PBKDF2(password, salt, { keySize: 256 / 32, iterations: 1000 });
                //Set the appropriate properties
                room.set('salt', salt);
                room.set('key', key);
                //Setup the Emit data package with the newly generated salt stringified into HEX.
                var emitData = {
                    room: room.get('name'),
                    salt: CryptoJS.enc.Hex.stringify(salt)
                };
                //Emit that data to the server and start the create room process on the server then continue with setting up a client.
                //Refer to Server.js for more information on the server implications.
                Socket.emit('createRoom', emitData);
            } else {
                //TODO:: implement server data null error.
            }

            //Setup a name check emit data packet this is used to ensure every username is unique. This is not necesary however makes a few things easier.
            var emitData2 = {
                username: App.CurrentClient.get('name')
            };
            //Emit checkname event refer to Server.js for server implications.
            Socket.emit('checkName', emitData2, function (data) {
                //Callback to start the chat if the name does not exist.
                if (data) {
                    if (!data.nameExists) {
                        //If the name does not exist on the server join the room and start the chat.
                        
                        //Setup join room emit data.
                        var emitData = {
                            name: App.CurrentClient.get('name'),
                            room: App.CurrentClient.get('currentRoom').get('name')
                        };
                        //Refer to Server.js for the server implications.
                        Socket.emit('joinRoom', emitData, function (data) {
                            //Get the current room data from the server.

                            if (data && data.users) {
                                //get the current room object and set the users property to the supplied server data.
                                var currentRoom = App.CurrentClient.get('currentRoom');
                                currentRoom.set('users', data.users);
                                //Set the document location to chat and begin the chat program.
                                document.location = document.location + "#/chat/";
                            } else {
                                //TODO:: implement server data null error.
                            }
                        });
                    } else {
                        //TODO:: Implement Name exists error catch;
                    }
                } else {
                    //TODO:: implement server data null error.
                }
            });
        });
    }
});

App.ChatRoute = Ember.Route.extend({
    model: function () {
        return App.CurrentClient;
    },
    setupController: function (controller, model) {
        controller.set('content', model);
        model.set('backgroundWorker', setInterval(function () {
            model.set('currentTime', new Date());
        }, 30000));
    }
});

App.ChatController = Ember.ObjectController.extend({
    newMessage: "",

    sendChat: function () {
        var currentRoom = App.CurrentClient.get('currentRoom');
        var name = App.CurrentClient.get('name');
        var key = currentRoom.get('key')
        var plainMessage = this.get('newMessage');

        var encrypted = CryptoJS.AES.encrypt(plainMessage, key, { iv: CryptoJS.lib.WordArray.random(128/8), format: JsonFormatter });

        var encryptedMessage = encrypted.toString();

        Socket.emit('sendChat', {
            name: name,
            message: encryptedMessage,
            postedAt: new Date()
            });

        this.set('newMessage', "");

        Em.$("#newMsg").focus();
    },

    disconnect: function () {
        clearInterval(this.get('backgroundWorker'));

        Socket.disconnect();

        App.CurrentClient.get('currentRoom').destroy();
        App.CurrentClient.destroy();

        document.location = "https://69.248.167.141:8001";
    },

    changeStatus: function () {
        App.CurrentClient.set('status', !App.CurrentClient.get('status'));
        var name = App.CurrentClient.get('name');
        var status = App.CurrentClient.get('status');

        Socket.emit('changeStatus', {
            name: name,
            status: status
        });
    },
});

//Ember Views
App.MessageTextField = Ember.TextField.extend({
    attributeBindings: ['autofocus'],

    keyUp: function (evt) {
        if (evt.which === 13) {
            this.get('controller').send("sendChat");
        }
    }
});

App.UserInfoTextField = Ember.TextField.extend({
    attributeBindings: ['autofocus'],

    keyUp: function (evt) {
        if (evt.which === 13) {
            this.get('controller').send("startNew");
        }
    }
});

App.ChatListView = Ember.View.extend({
    tagName: 'li',

    didInsertElement: function () {
        $('#chatList').scrollTop(1000000000);
        this._super();
    }
});

App.UserListView = Ember.View.extend({
    tagName: 'li',

    model:null,

    sendFile: function () {

    },

    startVoiceChat: function () {

    }
});

//Ember Formatters
Ember.Handlebars.registerBoundHelper('timeForm', function (data, options) {
    var time = options.hash.time;
    return moment(data).from(time);
});

//Socket-io-client configuation
Socket = io.connect('https://69.248.167.141:8001', { secure: true });

Socket.on('connect', function () {
    App.CurrentClient.set('connected', true);
});

Socket.on('addUser', function (data) {
    if (data && data.name && data.id && data.status) {
        App.CurrentClient.get('currentRoom').get('users').pushObject(App.User.create({ name: data.name, id: data.id, status: data.status }));
    } else {
        //TODO:: implement server data null error.
    }
});

Socket.on('removeUser', function (data) {
    if (data && data.id) {
        var users = App.CurrentClient.get('currentRoom').get('users');
        users.removeObject(users.findProperty('id', data.id));
    } else {
        //TODO:: implement server data null error.
    }
});

Socket.on('updateUser', function (data) {
    if (data && data.name && data.id && data.status) {
        var users = App.CurrentClient.get('currentRoom').get('users');
        users.find({ id: data.id }).set('status', data.status);
    } else {
        //TODO:: implement server data null error.
    }
});

Socket.on('updateChat', function (data) {
    if (data && data.message && data.name && data.postedAt) {
        var currentRoom = App.CurrentClient.get('currentRoom');
        var currentTime = App.CurrentClient.get('currentTime');
        if (data.name === "SERVER") {
            currentRoom.get('messages').pushObject(App.Message.create({
                name: data.name,
                message: data.message,
                postedAt: ((data.postedAt > currentTime)? currentTime : data.postedAt)
            }));
        } else {
            var key = currentRoom.get('key');
            var encrypted = JsonFormatter.parse(data.message);
            var decrypted = CryptoJS.AES.decrypt(encrypted, key, { iv: encrypted.iv });
            var plainMessage = decrypted.toString(CryptoJS.enc.Utf8);

            currentRoom.get('messages').pushObject(App.Message.create({
                name: data.name,
                message: plainMessage,
                //Inline if added to fix timestamp from showing future send dates.
                postedAt: ((data.postedAt > currentTime) ? currentTime : data.postedAt)
            }));
        }
    } else {
        //TODO:: implement server data null error.
    }
});
