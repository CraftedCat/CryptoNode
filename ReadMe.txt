This project contains the start of an ecnrypted chat program written in Node.js and Ember.js.

The server is written in Node.js utilizing the socket-io library for realtime updates of information.

The client uses Ember.js to handle templates and properties, while using CryptoJS for encryption of individual messages.

The application works based on a shared room and password. This allows the server to remain completely unaware of the password or what any of the encrypted messages mean.

This is in no way a finished product however it is the beginning of one please let me know of any glaring issues or features you would like added or removed. The idea of the project is to build a lightweight server/client platform that can be run and utilized on almost an hardware and software combination. To give people the opportunity to have their own encrypted chat networks for whatever it is they want to talk about. Privacy is a human right and extends to everyone in this world, and as such people should have access to a free way to ensure that right is upheald.


In order to use this application you can visit https://69.248.167.141:8001/

If you would like to build your own application you will need to change only one line of the "Client.js" file which is the Socket-io connection line.

It will appear like so in the file: "Socket = io.connect('https://69.248.167.141:8001', { secure: true });"

This will need to be changed to "Socket = io.connect('Your Host', { secure: true });"

An explanation of the encryption aspect:

The application utilizes SSL as the top layer of security or first pass. It then encrypts all client generated data with AES-256 CBC encryption. The AES key is generated based upon a user inputed password which is fed into a PBKDF2 function which generates the 256 bit key over 1000 iterations. This key is never shared over a connection, however the salt used to build the key is currently generated by the user who creates the room and stored on the server. This is the only way I could implement the PBKDF2 based key function as the salt should be randomly generated as often as possible. Currently the salt is randomly gnereated and has a 1024 byte size.

If there is anything wrong with this implementation of AES or how to do encryption of data over the web please let me know and I will do my best to fix it. 


A short TODO list:

- Add in encrypted file sharing
- Add in encrypted Voice Chat
- Add in error handling(null data recieved etc...)
- Ensure best practices
- Add in more server security (length checking ensuring correct data values etc...)
- Add in client side validation and requirments
- Ensure AES is implemented correctly and as securely as possible